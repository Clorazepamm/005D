# -*- coding: utf-8 -*-
"""Copia de Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12PXMPhQXIcOgHtAZCLUfKeKWAfW2e_hq
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import statsmodels.api as sm

url =  "https://github.com/sebastiancontz/test/raw/master/precios_autos.csv"
datos = pd.read_csv(url)
datos.drop(columns = "id_vehiculo", inplace = True)
datos.head()

datos.head()

datos.describe()

datos.info()

"""1.a. Descripción del dataset

1.b.Describir cada variable, su tipo de dato y su relevancia.

marca: Es una variable categórica, se basa en identificar las preferencias de los consumidores en cuanto a marcas de vehículos, esta variable tiene relación con con la calidad del vehículo y su valor.

modelo: Su relevancia podría estar en comprender qué modelos son más populares en el mercado y cómo pueden variar los precios entre diferentes modelos.

año: Representa el año de fabricación del vehículo. Sería una variable numérica, probablemente un número entero. Es relevante para comprender la edad de cada vehículo y su posible impacto en el precio y el rendimiento.

kilometros_recorridos: Indica la cantidad de kilómetros que ha recorrido el vehículo. Sería una variable numérica, probablemente un número decimal. Su relevancia radica en comprender el desgaste y el uso del vehículo, lo cual puede influir en su valor de mercado y en las decisiones de compra.

tipo_combustible: Representa el tipo de combustible que utiliza el vehículo, como gasolina, diésel, eléctrico, etc. Sería una variable categórica, generalmente una cadena de texto. Su relevancia está en comprender las preferencias del consumidor y posibles implicaciones en términos de costos de combustible y preocupaciones ambientales.

transmision: Indica el tipo de transmisión del vehículo, como manual o automática. Sería una variable categórica, generalmente una cadena de texto. Su relevancia podría estar en cómo afecta la experiencia de conducción y las preferencias del comprador.

tipo_propietario: Describe el tipo de propietario del vehículo, como particular o empresa. Sería una variable categórica, generalmente una cadena de texto. Su relevancia está en comprender si el vehículo ha sido usado principalmente para uso personal o comercial, lo cual puede influir en su mantenimiento y estado general.

rendimiento: Indica el rendimiento del vehículo en términos de eficiencia de combustible o millas por galón (MPG). Sería una variable numérica, probablemente un número decimal. Su relevancia está en comprender el costo operativo del vehículo y su impacto en la decisión de compra.

motor: Describe las características del motor del vehículo, como la cilindrada o la potencia. Sería una variable categórica o numérica, dependiendo de cómo se haya codificado en el conjunto de datos. Su relevancia está en comprender el rendimiento y la potencia del vehículo.

potencia: Indica la potencia del motor del vehículo, generalmente en caballos de fuerza (HP) o kilovatios (kW). Sería una variable numérica, probablemente un número entero o decimal. Su relevancia está en comprender la capacidad de aceleración y la fuerza del vehículo, lo cual puede influir en su precio y su atractivo para los compradores.

asientos: Representa la cantidad de asientos disponibles en el vehículo. Sería una variable numérica, probablemente un número entero. Su relevancia radica en comprender la capacidad de pasajeros del vehículo y su atractivo para diferentes tipos de compradores, como familias o conductores individuales.

precio_usd: Indica el precio del vehículo en dólares estadounidenses. Sería una variable numérica, probablemente un número decimal. Su relevancia está en comprender el valor monetario del vehículo y su relación con otras características del mismo.

##  2. Realizar estadisticas descriptivas
a.medidas de tendencia central
"""

# mediana
mediana = datos["precio_usd"].median()
print(f"Mediana: {mediana}")

## asientos
mediana = datos["asientos"].median()
print(f"Mediana: {mediana}")

## mediana de kilometros recorridos

mediana = datos["kilometros_recorridos"].median()
print(f"Mediana: {mediana}")

## media del rendimiento

media = datos["rendimiento"].mean()
print(f"Media: {media}")

## media de la potencia
media = datos["potencia"].mean()
print(f"Media: {media}")

## media de kilometros recorridos
media = datos["kilometros_recorridos"].mean()
print(f"Media: {media}")

## moda de la marca

moda = datos["marca"].mode()[0]
print(f"Moda_marca: {moda}")

## moda del modelo
moda= datos["modelo"].mode()[0]
print(f"Moda_modelo: {moda}")

## moda del tipo de combustible

moda = datos["tipo_combustible"].mode()[0]
print(f"Moda_tipo:combustible: {moda}")

## moda de transmision
moda = datos["transmision"].mode()
print(f"moda_transmision: {moda}")

## moda tipo de propietario
moda = datos["tipo_propietario"].mode()
print(f"Moda_tipo_propietario: {moda}")

"""b. Medidas de Dispersion"""

## varianza de rendimiento
varianza = datos["rendimiento"].var()
print(f"Varianza.rendimiento: {varianza}")

## varianza de potencia
varianza= datos["potencia"].var()
print(f"Varianza.potencia: {varianza}")

## desviacion estandar de los precios
std = datos["precio_usd"].std()
print(f"std: {std}")

"""## 3. Crear gráficos descriptivos y extraer insights relevantes:
A. Utilizar diferentes tipos de gráficos
"""

import seaborn as sns
import matplotlib.pyplot as plt

## 1.1 Grafico de distrubucion

sns.displot(data=datos, x="precio_usd")
plt.title("Distribución variable dependiente")

sns.scatterplot(data=datos, x="precio_usd", y="potencia")

"""En este grafico se observa que a menor potencia, más baja el precio. Y a mayor potencia aumenta un poco más el precio.

Se puede observar que entre 0 a 150 los precios se mantienen, osea que bajan al rededor de los 10.000 dolares, y desde los 150 hasta los 250 aprox los precios varian y suben al rededor de 15.000 a los 40.000 dolares.
"""

## Grafico de caja
sns.boxplot(x='precio_usd', y='marca', data=datos)

"""Como varian los precios según las marcas.

Nosotros observamos que los precios se comportaban distintos dependiendo las marcas, y eso lo comprobamos al momento de oobtener los betas, por ejemplo hyundai tiene un beta negativo (-5854.495247), eso quiere decir que tiene un impacto negativo en el precio, el hecho de ser hyundai baja 10.000 dolares el precio.
O por ejemplo BMW, tiene un beta positivo (2992.460965), y solo por el hecho de ser BMW sube 40.000 dolares el precio.
"""

## Grafico de caja
sns.boxplot(x='transmision', y='precio_usd', data=datos)

"""En este grafico podemos observas que el solo hecho de que el auto sea manual, el precio baja aprox 10.000 dolares. y al ser automatico el precio sue entre 20.000 y 40.000 dolares aprox.

## punto 4

a.Incluir análisis de correlación entre variables.
"""

sns.regplot(data=datos, x="motor", y="precio_usd", ci=None, line_kws={"color": "tab:red"})

sns.regplot(data=datos, x="potencia", y="precio_usd", ci=None, line_kws={"color": "tab:red"})

"""b.Utilizar matrices de correlación y gráficos de dispersión.

"""

import numpy as np
import matplotlib.pyplot as plt

x1 = np.random.rand(80)
y1 = np.random.rand(80)

x2 = np.arange(80)
y2 = np.arange(80)

x3 = np.arange(80)
y3 = -np.arange(80)

fig, axs = plt.subplots(1, 3, figsize=(15, 5))

axs[0].scatter(x1, y1)
axs[0].set_title('Correlación 0')

axs[1].scatter(x2, y2)
axs[1].set_title('Correlación 1')

axs[2].scatter(x3, y3)
axs[2].set_title('Correlación -1')

plt.tight_layout()
plt.show()

datos.dtypes

"""##5. Limpiar los outliers, si corresponde:
a. Describir el método utilizado para identificar outliers.
"""

import seaborn as sns
import matplotlib.pyplot as plt

sns.boxplot(x=datos['precio_usd'])
plt.show()

# definir función
def eliminar_outliers_por_iqr(dataframe, columna):
 q1 = dataframe[columna].quantile(0.25)
 q3 = dataframe[columna].quantile(0.75)
 iqr = q3 - q1

 lower_bound = q1 - 1.5 * iqr
 upper_bound = q3 + 1.5 * iqr

 dataframe_sin_outliers = dataframe[(dataframe[columna] >= lower_bound) & (dataframe[columna] <= upper_bound)].copy()

 return dataframe_sin_outliers

# aplicar función al dataset
datos = eliminar_outliers_por_iqr(datos, "precio_usd" )

"""b. Justificar la decisión de mantener o eliminar outliers específicos.

##6. Justificar la selección de variables independientes:
a. Explicar el criterio utilizado para la selección de variables.
b. Mencionar cualquier prueba estadística o análisis previo que respalde la
selección.
"""

datos.select_dtypes("number").corr()["precio_usd"].sort_values()

"""Estas son las variables que tienen mayor relevancia con el precio_usd.

Entonces mientras menos rendimiento tenga, menor es el precio. (correlacion inversa)

Mientras mayor potencia mayor precio.



"""

# sólo para demostrar, para guardar los cambios debemos sobreescribir la variable
datos = pd.get_dummies(datos, columns=["marca", "modelo", "tipo_combustible", "transmision","tipo_propietario"], drop_first=True, dtype=np.uint8)

import statsmodels.api as sm

columnas = list(datos.drop(columns="precio_usd").columns)

X = datos[columnas]
y = datos['precio_usd']

X = sm.add_constant(X)

modelo = sm.OLS(y, X)
resultado = modelo.fit()

round(resultado.pvalues, 4)

# definimos el nivel de significancia
alpha = 0.05
valores_p = round(resultado.pvalues, 4)

# todas las siguientes variables tiene un valor-p <= alpha
varianles_significativas = list(valores_p[valores_p <= alpha].index)
varianles_significativas.remove("const")

import statsmodels.api as sm


X = datos[varianles_significativas]
y = datos['precio_usd']

X = sm.add_constant(X)

modelo = sm.OLS(y, X)
resultado = modelo.fit()

pd.Series(resultado.params).sort_values()[:10]

pd.Series(resultado.params).sort_values(ascending=False)[:15]

"""El solo hecho de pertenecer al modelo A6 sube automaticamente 10000 dolares de pesos, mientras que el hecho de perteneces al modelo mustang baja 8000 dolares de precio.

El hecho de que ocupe combustible tipo petrol baja 6.000 dolares de precio.

por ejemplo: estos son los modelos más de lujo, solamente por ser de ese modelo, aunque compartan las mismas caracteristicas el auto hyundai con el modelo A6, por solamente ser ese modelo A6 sube automaticamente 10.000 dolares el precio.

Por ejemplo,hay dos variables: una modelo y otra marca. las marcas menos apetecidas son Mahindra Y hyundai, mientras que las más apetecidas son Mercedes y BMW. Los modelos menos apetecidos son Mustang y Sonata, mientas que los modelos mas apetecidos son A6 y Camry.

##7. Separar los datos en subconjuntos de entrenamiento y validación:
a. Describir la proporción de datos asignada a cada subconjunto.
b. Asegurar que la separación se realice de manera aleatoria y reproducible.
"""

# importamos la función desde la librería de scikit-learn
from sklearn.model_selection import train_test_split

# cargamos los datos (aquí tienen que usar su dataset)
datos = pd.read_csv(url)

# seleccionamos las variables independientes
X = datos[["año", "kilometros_recorridos"]]

# seleccionamos la variable dependiente
y = datos["precio_usd"]

# generamos los subconjuntos
X_entrenamiento, X_validacion, y_entrenamiento, y_validacion = train_test_split(X, y, test_size=0.3, random_state=2024)

"""##8. Ajustar un modelo de regresión lineal con los datos de entrenamiento:
a. Describir el proceso de ajuste del modelo
"""

X = datos[["año", "kilometros_recorridos", "rendimiento", "potencia", "asientos", "motor"]]


X = sm.add_constant(X)


y = datos["precio_usd"]


modelo = sm.OLS(y, X)


resultado = modelo.fit()

residuos = resultado.resid

"""Primero seleccionamos las variables que tienen mayor relevancia con respecto al precio_usd.

Segundo, agregamos la constante para incluir el intercepto en el modelo de regresión lineal. Esto permite que el modelo tenga un término de sesgo que ajusta la predicción general del precio de los autos.

Tercero, Definimos la variables dependiente, que es el precio_usd. Esta es la variable que el modelo intentará predecir utilizando las características seleccionadas.

Cuarto, creamos el modelo de regresión lineal utilizando statsmodels, con esto define el modelo que relaciona las variables independientes (X), con la variable dependiente.

Quinto, ajustamos el modelo de los datos para proporcionar mejores coeficientes para cada variable dependiente. "fir()" calcula los coeficientes que miniminizan la suma de los cuadrados de las diferencias entre las predicciones del modelo y los valores reales.

Y por último calculamos los residuos, que estos son las diferencias entre los valores observados (y) y los valores predichos del modelo. Si los residuos siguen una distribución normal y no muestran patrones específicos, indicaría que el modelo se ajusta bien a los datos.

##9. Analizar los coeficientes del modelo ajustado:
a. Interpretar los coeficientes obtenidos y su significancia.

b. Relacionar los coeficientes con las variables originales del dataset.
"""

resultado.params

"""Const: Este es el valor esperado del precio_usd cuando todas las variables independientes son cero. Aunque en el contexto de autos, todas las variables independientes nunca serán cero, este valor sirve como una base inicial de precio en el modelo.

Por cada año adicional, se espera que el precio_usd disminuya en 1,313.374 dólares. Esto sugiere que los autos más nuevos tienden a ser más caros.

Por cada kilómetro adicional recorrido, se espera que el precio_usd disminuya en aproximadamente 0.24 dólares. Esto indica que los autos con más kilómetros recorridos son generalmente más baratos.

Por cada unidad adicional de rendimiento, se espera que el precio_usd disminuya en 170.6194 dólares. Esta relación puede ser menos intuitiva y podría requerir una interpretación adicional basada en cómo se mide el rendimiento y su relación con el precio del auto en el dataset.

Por cada aumento de potencia, se espera que el precio_usd aumente en 139.8979 dólares. Ósea que los autos con más caballos de fuerza tienden a ser más caros.

Por cada asiento adicional, se espera que el precio_usd aumente en 1,961.701 dólares. Esto indica que autos con más asientos (probablemente autos más grandes o de lujo) tienden a ser más caros.

##10. Validar los supuestos del modelo:
a. Verificar los supuestos de normalidad, homocedasticidad, independencia y
linealidad.
b. Incluir pruebas estadísticas y gráficos de diagnóstico.
"""

import statsmodels.api as sm
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

residuos = resultado.resid
round(np.mean(residuos), 4)

"""si cumple con el supuesto de linealidad porque es cercana a 0"""

sm.qqplot(residuos, line='45', fit=True)
plt.show()

"""No cumple con el supuesto de normalidad porque los puntos en el gráfico deberian fromar aprox una linea recta, en ese caso no es así, osea que los residuos no siguen una distribución normal."""

plt.scatter(resultado.fittedvalues, resultado.resid)
plt.axhline(y=0, color='r', linestyle='--')
plt.xlabel('Valores Ajustados ($\hat{y}$)')
plt.ylabel('Residuos')
plt.title('Residuos vs. Valores Ajustados')
plt.tight_layout()
plt.show()

from statsmodels.stats.diagnostic import het_breuschpagan

estadistico_bp, valor_p, _, _ = het_breuschpagan(residuos, X)
print(f"Valor-p: {valor_p}")
print(f"¿{valor_p} < 0.05?: {valor_p <= 0.05}")

"""El valor p (1.020481615343343e-06) es menor que 0.05, entonces se rechaza la hipótesis nula, lo que sugiere la presencia de heterocedasticidad."""

from statsmodels.stats.diagnostic import het_breuschpagan

bp_test = het_breuschpagan(residuos, resultado.model.exog)
bp_stat, bp_pvalue, _, _ = bp_test

print(f'Estadístico de Breusch-Pagan: {bp_stat}, valor-p: {bp_pvalue}')
print("Nivel de significancia: 0.05")
print(f"¿valor-p < 0.05?: {bp_pvalue < 0.05}")

"""Dado que el valor-p (4.5153890270308115e-07) es menor que el nivel de significancia (0.05), rechazamos la hipótesis nula de homocedasticidad, lo que sugiere la presencia de heterocedasticidad.


"""

from statsmodels.stats.stattools import durbin_watson

dw_stat = durbin_watson(residuos)
print(dw_stat)

"""Si se cumple, pero como el valor es 2 sugiere que no hay autocorrelación.

##11. Evaluar las métricas de rendimiento respecto a los datos de validación:
a. Calcular y explicar métricas como R², RMSE, MAE, etc.
b. Comparar el rendimiento del modelo con cualquier otro modelo alternativo
probado.
"""

from statsmodels.tools.eval_measures import rmse

# seleccionamos las variables independientes
X = datos[["kilometros_recorridos", "motor"]]

# seleccionamos las variables dependientes
y = datos["precio_usd"]

# agregamos el intercepto a los datos
X = sm.add_constant(X)

# ajustamos el modelo
modelo = sm.OLS(y, X)

# generamos los resultados
resultado = modelo.fit()

# obtenemos los valores ajustados
y_hat = resultado.fittedvalues

# calculamos el RMSE
rmse_modelo = rmse(y, y_hat)

# reportamos la métrica
print(f"RMSE: {rmse_modelo}")

"""RMSE
Recuerde que Error Cuadrático Medio (MSE) nos permite cuantificar los errores de nuestro modelo.
El RMSE es simplemente la raíz cuadrada del MSE, pero la principal diferencia es que los errores en las mismas unidades que la variable de respuesta.

El RMSE de 9117.39602842962 indica que nuestras predicciones de precios de autos tienen un error promedio de aproximadamente $9117.4. Esto sugiere que nuestro modelo de predicción actual no es tan preciso como deseamos.
"""

print(f"R^2: {resultado.rsquared}")

"""El valor de R^2 significa que alrededor de un 53,79% de la
variabilidad en la variable de respuesta (precio_usd), puede ser explicada por el modelo de regresión lineal.
"""